# 선물하기 기능 리팩토링&고도화

## 1. 브랜치 전략
1. main 브랜치를 기준으로 작업할 내용에 대한 브랜치를 하나씩 생성합니다.
2. 생성된 브랜치에서 리팩토링 작업을 수행하고, 작업이 완료되면 main 브랜치에 merge합니다.
3. 이 과정을 반복하여 프로젝트를 개선해 나갑니다.

> 개인 프로젝트이기 때문에 브랜치 전략을 최대한 단순화 하였습니다. 

> 코드 리뷰는 공개되어있는 생성형 AI(chatGPT, Claude 등)을 적극 활용합니다.
## 2. 브랜치, 커밋 컨벤션
### 브랜치 컨벤션
#### feature/<feature-name>
- 역할: 새로운 기능을 추가하거나 기존 기능을 변경하기 위한 브랜치입니다.
- 사용 시점: 새로운 기능을 추가하거나 기존 기능을 개선할 때 `main` 브랜치에서 새로운 기능 브랜치를 생성하여 작업합니다. 작업이 완료되면 `main` 브랜치에 병합합니다.
- 예시: feature/user-authentication, feature/product-add
#### refactor/<refactor-name>
  - 역할: 코드 리팩토링을 위한 브랜치입니다. 코드의 구조를 개선하거나 클린업 작업을 진행할 때 사용합니다.
  - 사용 시점: 코드의 품질을 향상시키기 위해 리팩토링이 필요할 때 `main` 브랜치에서 리팩토링 브랜치를 생성하여 작업합니다. 작업이 완료되면 `main` 브랜치에 병합합니다.
  - 예시: refactor/cleanup-database-code, refactor/optimize-performance
#### bugfix/<bugfix-name>
  - 역할: 버그를 수정하기 위한 브랜치입니다.
  - 사용 시점: 발견된 버그를 수정할 때 `main` 브랜치에서 버그 수정 브랜치를 생성하여 작업합니다. 수정이 완료되면 `main` 브랜치에 병합합니다.
  - 예시: bugfix/fix-login-issue, bugfix/correct-typo
### 커밋 컨벤션
커밋 메시지는 다음 형식을 따릅니다:
```text
<type>: <subject>

<body>
```
#### Type
커밋의 유형을 나타냅니다:
- feat: 새로운 기능 추가
- refactor: 코드 리팩토링
- fix: 버그 수정
- docs: 문서 수정
- style: 코드 포맷팅, 세미콜론 누락, 코드 변경이 없는 경우
- test: 테스트 코드 추가 및 수정
- chore: 빌드 업무 수정, 패키지 매니저 수정, 좀 잡다한 일들
#### Subject
커밋의 간단한 설명을 포함합니다:
- 50자를 넘지 않도록 합니다.
- 마침표를 끝에 붙이지 않습니다.
- 명령문으로 작성합니다.
#### Body
커밋에 대한 상세한 설명을 포함합니다 (선택사항):
- 어떻게 보다는 무엇을, 왜 변경했는지 설명합니다.
- 여러 줄의 메시지를 작성할 땐 "-"로 구분합니다.


## 3. gitignore 설정
```.gitignore
# Gradle 관련
.gradle/
build/
!gradle/wrapper/gradle-wrapper.jar
!gradle/wrapper/gradle-wrapper.properties

# IntelliJ IDEA
.idea/
*.iml

# 운영체제 및 환경 관련 파일
*.log
*.tmp
*.bak
.DS_Store

# 환경 설정 파일(외부 API 호출을 위한 코드(토큰)를 숨기기 위해)
application-dev.properties
```
## 4.리팩토링&고도화 실행 요소
### 4.1 객체지향 검증
**왜?** 이전에 코드를 작성할 때, 기능 구현에만 집중하다 보니 객체지향 원칙을 충분히 고려하지 않았습니다.
멘토님께서 코드 리뷰를 해주셨지만, 시간 부족으로 인해 충분한 피드백을 받지 못했기에, 
현재로서는 코드가 객체지향적으로 잘 작성되었는지 불안한 마음이 있습니다. 
이에 따라, 객체지향 설계 원칙을 체계적으로 공부하고 적용해 보기 위해 "객체지향 검증"을 실행 요소로 지정하였습니다.